# 双检锁: 聪明,但无效

## 什么是DCL？

DCL专门设计为惰性初始化，即一个类只要在需要的时候才初始化一个自己的对象。
<pre>
class SomeClass {
	private Resource resource = null;
	public Resource getResource() {
		if (resource == null)
			resource = new Resource();
		return resource;
	}
}
</pre>

为什么要惰性初始化?创建一个```Resource```是一个耗资源的操作,而SomeClass的用户并不总是调用getResource()在任何运行时间。就是说，可以在创建```SomeClass```的时候忽略创建```Resource```对象，会让```SomeClass```创建得更快。延迟一些初始化操作直到真正需要可以帮助程序启动更快。

如果使用```SomeClass```在多线程应用下会怎样?会有一个不同的结果:两个线程可能同时运行查看```resource```是否为空。结果,初始化resource两次。在一个多线程环境,你需要声明```getResource()```为```synchronized```。

但是,同步方法运行非常慢——比正常方法慢了100倍。惰性初始化初衷就是为了效率。如果为了启动时间而花费了运行时间，这不是一个好的交易。

DCL初衷是给我们最好的，使用DCL,```getResource()```方法可能看起来这样:

<pre>
class SomeClass {
	private Resource resource = null;
	public Resource getResource() {
		if (resource == null) {
			synchronized {
				if (resource == null)
					resource = new Resource();
			}
		}
		return resource;
	}
}
</pre>

在第一次调用```getResource()```之后,```resource```已经初始化，后面的调用会避免在最常用的代码路径中进行同步。DCL还通过在同步块中第二次检查```resource```来避免竞争条件。这个意味着只有一个线程会尝试初始化```resource```。DCL似乎看起来是一个充满的注意——但是不会成功。

## 查看JAVA内存模型

很多情况，DCL不保证正常工作。要知道原因，我们需要查看JVM和JVM运行的计算机环境之间的关系。特别，我们需要查看Java内存模型(JMM),定义于Java Language Specification的第17章，详细说明了Java如何处理线程和内存之间的交互。

不像大多数其他语言，Java通过一个潜在的内存模型定义了它与底层硬件的关系，这一模型让所有的Java平台保持着"Write Once,Run Anywhere"的宗旨。相比之下，其他语言类似C和C++没有一个标准的内存模型；在这种语言中，程序继承程序运行的硬件平台的内存模型。

当运行在一个同步(单线程)环境，一个程序和内存的交互是非常简单或者至少看起来这样。程序存储东西到内存位置并且期望下次访问内存依然在那里。

事实上，事实是完全不同的，但是由编译器、JVM和硬件维护的复杂的错觉隐藏在我们的面前。尽管我们认为程序运行有序——特别是通过程序代码的有序。但这并不完全相同。编译器，处理器和缓存会自由的排序程序和数据的库，并且不影响计算结果。例如，编译器根据不同的情况程序建议来生成结构并且存储在寄存器而不是内存。处理器可能并发或者无序的运行这个结构(编译器编译后的结构)。并且缓存需要的变量写入提交到主存中。JMM认为所有这些变量排序和最优并且接受。所以环境主张```as-if-serial```所以你可以实现相同的结果指令在严格的顺序环境中执行。

编译器，处理器和缓存重组排列程序操作顺序为了实现高性能。最近，我们可以看到计算机性能极高的提高。提高处理器时钟比例已经贡献很多高性能，提高并行(管道表单和超标量体系结构单元，动态的结构调度和推测运行，还有复杂的多级内存缓存)也有更多核心贡献者，同一时间，编写编译器的任务变得更加的复杂，并且编译器必须保护程序员不受这些复杂性的影响。

当编写单线程程序时，你不能看到这些变量结构或者内存操作重新排列的影响。然而，在多线程编程，这个情况大大不同——一个线程可以读取内存位置可能已经被其他线程写了。如果线程A重定义一些变量按照一定的顺序，在没有同步的情况下，线程B可能看不到相同的顺序——或者更糟糕的是根本就看不见。这个结果是因为编译器重组结构或临时存储一个变量在寄存器然后写内存外。或者因为处理器并行或者用比编译器指定的不同顺序运行这个结构；又或者结构在不同的内存区块，然后缓存以不同的顺序更新了相应的主存位置，而不是它们所写的顺序。无论什么情况，多线程程序本质上都是不可预测的，除非您显式地确保线程使用同步具有一致的内存视图。

## 同步的真实意义

Java把每个线程都当作是在自己的本地内存中运行，每个线程都与一个共享主内存进行对话和同步。甚至在一个单处理器系统，这种模式也讲得通因为内存缓存和处理器寄存器的使用对存储变量的影响。当一个线程重定义它本地内存位置，这个会最后也会展示在主内存,并且JMM定义什么时候JVM会在本地和主内存之间运输数据的规则。Java架构师认识到，过度限制的内存模型会严重破坏程序的性能。他们试图设计一种内存模型，使程序能够在现代计算机硬件上运行良好，同时还提供保证，允许线程以可预测的方式进行交互。

Java重要的工具关于可以预期地呈现线程之间的交互是```synchronized```关键字。多数程序认为```synchronized```是强制执行互斥信号量的术语(互斥量)来阻止由多个线程组成关键部分同一时间运行。不幸的是，直觉并不能直接描述```synchronized```的意思。

```synchronized```语义确实包括基于信号量状态的相互排斥，但是他们也包括关于同步线程到主存的交互规则。特别的是，捕获或释放锁会触发内存屏障 —— 线程的本地内存和主内存之间的强制同步。(有些处理器 —— 像Alpha —— 有明确的机器执行记忆障碍结构。)当一个线程存在一个```synchronized```块，他表现一个写屏障 —— 它必须在释放锁之前将该块中修改的所有变量清除到主内存中。同样地，当进入一个```synchronized```块，它表现一个读屏障 —— 这就好像本地的记忆被否定了一样，并且它必须从主内存中拉下所有在这个块中将会指向的变量。


同步的正确使用保证了一个线程能够以可预测的方式看到另一个线程的影响。只有当线程A和B在同一对象上同步时，JMM才会保证线程B看的到线程A造成的变化，而线程A在synchronized块内部所做的更改会以原子的方式出现在线程B上(要么整个块执行，要么没有执行。)此外，JMM确保确保同步于同一对象上的同步块将以与程序中相同的顺序执行。

## 所以DCL的问题是什么?

DCL依赖一个非同步的```resource```字段使用。这似乎是无害的，但事实并非如此。原因是，想象线程A进入```synchronized```块，执行语句```resource = new Resource();```此时线程B刚刚进入```getResource()```。考虑这个初始化内存的影响。新的```Resource```对象内存将会被分配；```Resource```的构造器将会被调用，初始化新对象的成员变量；并且```SomeClass```的属性```resource```会被标记引用这个新创建的对象。

然而，因为线程B在一个同步块中不执行，它可能看到这些内存操作和A线程相比有不同的顺序。B可以按照下面的顺序看到这些事件(并且编译器会自由的排列结构像这样):分配内存,标记引用到```resource```,调用构造器。假设在分配了内存并设置了资源字段之后，线程B出现了，但是构造器还没被调用。它看起来```resource```是not null。跳过了```synchronized```块，并且返回一个应用一个部分构造的```Resource```！不用说，结果既不期望也不是想要的。

在这个例子中，很多人刚开始保持怀疑态度。许多高智商的程序员都试图修复DCL，以使其能够工作，但这些所谓的固定版本都没有起作用。应该注意的是，DCL实际上可能在某些版本的jvm上工作——因为很少有jvm能够正确地实现JMM。然而，不能希望程序的正确性依赖于实现细节 —— 特别是错误 —— 特定于您所使用的特定JVM的特定版本。

其他并发性危害是在DCL中嵌入的，而且在任何不同步的引用中，都是由另一个线程编写的，甚至是无害的读取。假设A完成初始化```Resource```并且离开了```synchronized```块时线程B进入了```getResource()```。现在```Resource```整个初始化，并且线程A刷新它本地内存到主内存中。```resource```的变量都指向其他内存中的对象存储通过，这些都会刷出去。虽然线程B可能对新创建的资源有一个有效的引用，因为它没有执行读屏障，但是它仍然可以看到资源的成员字段的陈旧值。

## Volatile和你想的不一样

一个通常的建议是将```SomeClass```的```resource```属性声明为```volatile```。然而，虽然JMM可以防止对volatile变量的写操作，使其在相互之间重新排序，并确保它们立即被刷新到主内存。它仍然允许对volatile变量的读取和写入，以对非易失性的读写进行重新排序。这意味着——除非所有的```Resource```属性都是```volatile```——线程B仍然可以感知到在资源被设置为引用新创建的资源之后，构造函数的作用。

## DCL的替代品

解决DCL的最有效的方法是避免使用它。当然，避免它的最简单的方法是使用同步。当一个线程被另一个线程写入时，您应该使用同步来保证修改可以以可预测的方式对其他线程可见。

避免DCL问题的另一种选择是放弃延迟初始化，而是使用热切初始化。