# 十二要素应用(12-factors APP)

## 介绍

现代，软件通常被作为一种服务来交付：比如web应用，或者SaaS。十二因素应用程序是一种构建软件即服务应用(SaaS)程序的方法:

- 使用标准声明式自动化创建来达到减少开发者参与项目所花费的时间。
- 和底层操作系统有一个清晰的约定，在不同环境下提供最大的可移植性。
- 在现代云平台可以完美发布，不需要服务器和系统管理。
- 尽量减少开发和生产的差异，从而实现最大敏捷性持续部署。
- 不需要大成都的改变工具，架构或者开发测试下进行扩容。

十二要素方法论可以应用在任何程序语言编写的应用上，即使使用了联合的服务(数据库，队列，内存缓存等)。

## 背景

编写这个文档的贡献者已经直接参与过上百个应用的开发和发布，并且通过Heroku平台间接见证过成百上千个应用的发展，运行和扩展。

本文结合了我们所有各种各样的SaaS应用的经验和见识。是开发这种应用的一个标准，并特别关注于应用程序如何保持良性成长，开发者之间如何进行有效的代码协作，以及如何避免软件污染。

我们的初衷是为了分享在现代应用开发中的一些系统化的问题，共享论述这些问题的词汇，并提供一个宽广的概念上的解决方案。

## 谁能读这篇文章？

SaaS的开发者和运维人员。

## 十二要素(12-factors)

### 1.基准代码

一份追踪版本控制并且多出部署的代码。

一个12要素应用通常会使用一个版本控制系统，如```Git```，```Mercurial```或者```Subversion```。
在基准代码和应用之间总有一个一对一关联：

- 如果有多个基准代码，不是应用而是一个分发系统。系统中的每个组件都是一个应用。并且每个应用能够单独遵守。
- 多应用共享同一个代码是违反12要素。解决方法是通过类库(可以通过依赖管理来包含进去)来共享代码。


一个基准代码一个应用，但是可能会存在一个应用被多次发布。一个```deploy```就是一个应用的运行实例。这个通常是一个生产环境，拥有多个站点。或者是多个开发人员拥有同一个代码运行在本地开发环境。这些也可以看成每个```deploy``` hahaha...

所有部署的代码库都是相同的，尽管可能出现不同的版本在发布的时候。(开发人员本地运行的版本可能还没有pull到最新版本)。

### 2.依赖

显示声明依赖关系。

这个没啥好说的，就是使用像maven gradle bundler等工具管理。

### 3.配置

在环境中存储配置。

应用环境的配置是在部署(发布，生产，开发环境等)时会发生变化的一切，这包括：

- 数据库，内存或者其它服务的资源。
- 第三方服务的凭证，如亚马逊或者推特。
- 每个部署特有的配置，如域名等。

应用通常会存储在代码中使用常量存储配置。这个是违反了12因素的需要从代码中严格分离配置的规则。配置在部署中有很大的不同，代码都是相同的。

测试一个应用是否正确的将配置排除在代码外的最好方式是将此应用立即开源并且确定不会暴露任何敏感信息！

并不是所有的配置都要排除在外，比如Rails的```config/routes.rb```或者是```pom```maven的文件，所有应用环境都一样的。不需要排除。

另外一种解决方案是使用配置文件，但不把它们归入版本控制中去，像```Rails```的```config/database.yml```。这个对于在代码里的配置来说也是一个巨大的提升，不过还是很脆弱：它很容易把配置写错在代码中，总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。

实现了十二因素的应用存储在环境变量中(通常缩写为env vars或env)。环境变量通常在不同发布中比代码容易改变；不像配置文件，它们很少会被误写入代码中；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。

配置管理的另一方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 development,test, 和 production 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 staging 或 qa 。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 joes-staging ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。

```12-Factor```应用中，环境变量的粒度要足够小且相对独立。才不会用组成一个所谓的"环境"。而是独立在每个部署之中。当应用程序不断扩张，需要更多种类的部署时，这种配置管理才能更加平滑。

### 4.后端服务

把后端服务当成附加资源。

后端服务是指应用操作时候通过网络进行消费的部分。例如数据存储(MySQL或CouchDB等)，消息/队列系统(RabbitMQ或Beanstalkd),SMTP服务(Postfix)或者缓存系统(Memcached)等。

像数据库这样的后台服务通常由与应用程序运行时部署相同的系统管理员管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 SMTP（例如 Postmark），数据收集服务（例如 New Relic 或 Loggly），数据存储服务（如 Amazon S3），以及使用 API 访问的服务（例如 Twitter, Google Maps, Last.fm）。

12-Factor 应用不会区别对待本地或第三方服务。 对应用程序而言，两种都是附加资源，通过一个 url 或是其他存储在 配置 中的服务定位/服务证书来获取数据。12-Factor 应用的任意 部署 ，都应该可以在不进行任何代码改动的情况下，将本地 MySQL 数据库换成第三方服务（例如 Amazon RDS）。类似的，本地 SMTP 服务应该也可以和第三方 SMTP 服务（例如 Postmark ）互换。上述 2 个例子中，仅需修改配置中的资源地址。

每个不同的后端服务是一份 资源 。例如，一个 MySQL 数据库是一个资源，两个 MySQL 数据库（用来数据分区）就被当作是 2 个不同的资源。12-Factor 应用将这些数据库都视作 附加资源 ，这些资源和它们附属的部署保持松耦合。

![](https://i.imgur.com/QZ11pFl.png)

部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。

### 5.构建，发布，运行

严格分离构建和运行。

一个基准代码发布(非开发环境下)通过三个阶段：

- 构建阶段 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件。
- 发布阶段 会将构建的结果和当前部署所需 配置 相结合，并能够立刻在运行环境中投入使用。
- 运行阶段 （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 进程。

12-facfor 应用严格区分构建，发布，运行这三个步骤。 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。

部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， Capistrano 将所有发布版本都存储在一个叫 ```releases``` 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的``` rollback ```命令可以很容易地实现回退版本的功能。

每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（```2011-04-06-20:32:17```），亦或是一个增长的数字（```v100```）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。

新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。

### 6.进程

以一个或多个无状态进程运行应用。

应用以一个或多个进程运行在运行环境中。

最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如```python my_script.py```）。另外一个极端情况是，复杂的应用可能会使用很多 进程类型 ，也就是零个或多个进程实例。

12-Factor 应用的进程必须无状态且 无共享 。 任何需要持久化的数据都要存储在 后端服务 内，比如数据库。

内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。

源文件打包工具（Jammit, django-compressor） 使用文件系统来缓存编译过的源文件。12-Factor 应用更倾向于在 构建步骤 做此动作——正如 Rails资源管道 ，而不是在运行阶段。

一些互联网系统依赖于 “粘性 session”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。

### 7.端口绑定

通过端口绑定提供服务。

互联网应用有时会运行于服务器的容器之中。例如``` PHP``` 经常作为 ```Apache HTTPD ```的一个模块来运行，正如 ```Java ```运行于 ```Tomcat``` 。

也就是传统的Spring应用是运行在服务器容器中而SpringBoot应用是符合12-Factor应用的。

12-Factor 应用完全自我加载 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。

本地环境中，开发人员通过类似```http://localhost:5000/```的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。

通常的实现思路是，将网络服务器类库通过 依赖声明 载入应用。例如，Python 的 Tornado, Ruby 的Thin , Java 以及其他基于 JVM 语言的 Jetty。完全由 用户端 ，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。

HTTP 并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用 XMPP 的 ejabberd ， 以及使用 Redis 协议 的 Redis 。

还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的 后端服务 ，调用方将服务方提供的相应 URL 当作资源存入 配置 以备将来调用。

### 8.并发

通过进程模型进行扩展。

任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，PHP 进程作为 Apache 的子进程存在，随请求按需启动。Java 进程则采取了相反的方式，在程序启动之初 JVM 就提供了一个超级进程储备了大量的系统资源(CPU 和内存)，并通过多线程实现内部的并发管理。上述 2 个例子中，进程是开发人员可以操作的最小单位。

在 12-factor 应用中，进程是一等公民。12-Factor 应用的进程主要借鉴于 unix 守护进程模型 。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的 进程类型 。例如，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责。

![](https://i.imgur.com/QkPRb5u.png)

这并不包括个别较为特殊的进程，例如通过虚拟机的线程处理并发的内部运算，或是使用诸如 EventMachine, Twisted, Node.js 的异步/事件触发模型。但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。

上述进程模型会在系统急需扩展时大放异彩。 12-Factor 应用的进程所具备的无共享，水平分区的特性 意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 进程构成 。

12-Factor 应用的进程 不需要守护进程 或是写入 PID 文件。相反的，应该借助操作系统的进程管理器(例如 Upstart ，分布式的进程管理云平台，或是类似 Foreman 的工具)，来管理 输出流 ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。

### 9.易处理

快速启动和优雅终止可最大化健壮性

12-Factor 应用的 进程 是 易处理（disposable）的，意思是说它们可以瞬间开启或停止。 这有利于快速、弹性的伸缩应用，迅速部署变化的 代码 或 配置 ，稳健的部署应用。

进程应当追求 最小启动时间 。 理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的 发布 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。

进程 一旦接收 终止信号（```SIGTERM```） 就会优雅的终止 。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。

对于 worker 进程来说，优雅终止是指将当前任务退回队列。例如，RabbitMQ 中，worker 可以发送一个NACK信号。 Beanstalkd 中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如 Delayed Job 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 可重复执行 ， 这主要由将结果包装进事务或是使重复操作 幂等 来实现。

进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 Beanstalkd ，它可以在客户端断开或超时后自动退回任务。无论如何，12-Factor 应用都应该可以设计能够应对意外的、不优雅的终结。Crash-only design 将这种概念转化为 合乎逻辑的理论。

### 10.开发环境与线上环境等价

尽可能保持开发，预发布，线上环境相同。

从以往经验来看，开发环境（即开发人员的本地 部署）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面：

- 时间差异： 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。
- 人员差异： 开发人员编写代码，运维人员部署代码。
- 工具差异： 开发人员或许使用 Nginx，SQLite，OS X，而线上环境使用 Apache，MySQL 以及 Linux。
12-Factor 应用想要做到 持续部署 就必须缩小本地与线上差异。 再回头看上面所描述的三个差异:

- 缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。
- 缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。
- 缩小工具差异：尽量保证开发环境以及线上环境的一致性。

将上述总结变为一个表格如下：

<table>
	<tr>
		<th></th><th>传统应用</th><th>12-Factor 应用</th>
	</tr>
	<tr>
		<td>每次部署间隔</td><td>数周</td><td>几小时</td>
	</tr>
	<tr>
		<td>开发人员 vs 运维人员</td><td>不同的人</td><td>相同的人</td>
	</tr>

</table>

后端服务 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的 适配器 。下列表格提供了一些例子。

<table>
	<tr>
		<th>类型</th><th>语言</th><th>类库</th><th>适配器</th>
	</tr>
	<tr>
		<td>数据库</td><td>Ruby/Rails</td><td>ActiveRecord</td><td>MySQL, PostgreSQL, SQLite
</td>
	</tr>
	<tr>
		<td>队列</td><td>Python/Django</td><td>Celery</td><td>RabbitMQ, Beanstalkd, Redis</td>
	</tr>
	<tr>
		<td>缓存	</td><td>Ruby/Rails	</td><td>ActiveSupport::Cache	</td><td>Memory, filesystem, Memcached
</td>
	</tr>
</table>

开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用 SQLite 线上使用 PostgreSQL；又如本地缓存在进程内存中而线上存入 Memcached。

*** 12-Factor 应用的开发人员应该反对在不同环境间使用不同的后端服务 ***，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。

与此同时，轻量的本地服务也不像以前那样引人注目。借助于Homebrew，apt-get等现代的打包系统，诸如Memcached、PostgreSQL、RabbitMQ 等后端服务的安装与运行也并不复杂。此外，使用类似 Chef 和 Puppet 的声明式配置工具，结合像 Vagrant 这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。

不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。

### 日志

把日志当做事件流

日志 使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。

日志应该是 事件流 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。尽管在回溯问题时可能需要看很多行，日志最原始的格式确实是一个事件一行。日志没有确定开始和结束，但随着应用在运行会持续的增加。

12-factor应用本身从不考虑存储自己的输出流。 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（stdout）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。

在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 Logplex 和 Fluent 的开源工具可以达到这个目的。

这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 Splunk 这样的日志索引及分析系统，或 Hadoop/Hive 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：

- 找出过去一段时间特殊的事件。
- 图形化一个大规模的趋势，比如每分钟的请求量。
- 根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。

### 12.管理进程

后台管理任务当做一次性进程运行。

进程构成（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如：

- 运行数据移植（Django 中的 manage.py migrate, Rails 中的 rake db:migrate）。
- 运行一个控制台（也被称为 REPL shell），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个 REPL 工具（python 或 perl） ，或是其他命令（Ruby 使用 irb, Rails 使用 rails console）。
- 运行一些提交到代码仓库的一次性脚本。
一次性管理进程应该和正常的 常驻进程 使用同样的环境。这些管理进程和任何其他的进程一样使用相同的 代码 和 配置 ，基于某个 发布版本 运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。

所有进程类型应该使用同样的 依赖隔离 技术。例如，如果Ruby的web进程使用了命令```bundle exec thin start```，那么数据库移植应使用 ```bundle exec rake db:migrate``` 。同样的，如果一个 Python 程序使用了 Virtualenv，则需要在运行 Tornado Web 服务器和任何 manage.py 管理进程时引入 bin/python 。

12-factor 尤其青睐那些提供了 REPL shell 的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用 shell 命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用ssh或是运行环境提供的其他机制来运行这样的进程。